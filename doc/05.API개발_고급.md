# API 개발 고급

## 조회용 샘플 데이터 입력
## 지연로딩과 조회 성능 최적화
주문 + 배송정보 + 회원을 조회하는 API를 만들자   
지연로딩 때문에 발생하는 성능 문제를 단계적으로 해결

> 참고 : 실무에서 JPA를 사용하려면 100% 이해해야 한다.

엔티티를 직접 노출할 때는 양방향 연관관계가 걸린 곳은 꼭 한 곳을 @JsonIgnore 처리해야한다.   
안 그러면 양쪽을 서로 호출하면서 무한 루프에 걸린다.

그냥 DTO 로 반환하여 응답하도록 하자

지연 로딩을 피하기 위해 즉시 로딩으로 설정하면 안된다. 즉시로딩 때문에 연관관계가
필요 없는 경우에도 데이터를 항상 조회해서 성능 문제가 발생할 수 있다. 즉시 로딩으로
설정하면 성능 튜닝이 매우 어려워진다.
항상 지연 로딩을 기본으로 하고, 성능 최적화가 필요한 경우에는 페치 조인을 사용해라

### 정리
엔티티를 DTO로 변환 하거나 DTO로 바로 조회하는 두가지 방법은 각각 장단점이 있다.
둘 중 상황에 따라 더 나은 방법을 선택하면 된다. 엔티티로 조회하면 레포지토리
재사용 성도 좋고, 개발도 단순해진다. 따라서 권장하는 방법은 다음과 같다.

### 쿼리 방식 선택 권장 순서
1. 우선 엔티티를 DTO로 변환하는 방법을 선택한다.
2. 필요하면 패치조인으로 성능을 최적화 한다. -> 대부분의 성능이슈가 해결된다.
3. 그래도 안되면 DTO로 직접 조회하는 방법을 사용한다.
4. 최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template를 사용해서SQL을 직접 사용한다.

## 컬렉션 조회 최적화

벌크연산의 문제가 있음

fetch join + distinct 로 해결 가능 but 치명적인 단점이 있음

* 컬렉션 페치조인 하면 페이징 불가
-> 메모리에서 페이징 처리함 
> 컬렉션 페치조인은 1개만 사용할 수 있다. 컬렉션 둘 이상의 페치조인을 사용하면 안된다.
> 데이터가 부정합하게 조회될 수 있다. 자세한 내용은 자바 ORM 표준 JPA 프로그래밍으로 참고하자

## 페이징과 한계 돌파

- 컬렉션을 페치조인하면 페이징이 불가능하다.
  - 컬렉션을 페치조인하면 일대다 조인이 발생하므로 데이터가 예측할 수 없이 증가한다.
  - 일다대에서 일(1) 기준으로 페이징하는 것이 목적이다. 그런데 데이터는 다를 기준으로 row가 생성된다.
  - Order 기준으로 페이징하고 싶은데 다인 OrderItem을 조회하면 orderItem이 기준이 되버린다.
  - (더 자세한 내용은 자바 ORM 표준 - 페치 조인 한계 참조)
- 이 경우 하이버네이트는 경고 로그를 남기고 모든 DB 데이터를 읽어서 메모리에서 페이징을 시도한다.최악의 경우 장애로 이어질 수 있다.


### 한계 돌파
>그렇다면 페이징 + 컬렉션 엔티티를 함께 조회하려면 어떻게 해야할까?
> 지금부터 코드도 단순하고, 성능 최적화도 보장하는 매우 강력한 방법을 소개한다.

- 먼저 ToOne 관계를 모두 페치 조인한다. TOOne관계는 row수를 증가시키지 않으므로 페이징 
- 쿼리에 영향을 주지 않는다.
- 컬렉션은 지연로딩으로 조회한다.
- 지연 로딩 성능 최적화를 위해 hibernate.default_batch_fetch_size, @BatchSize 를 적용한다.
  - hibernate.defautl_batch_fetch_size: 글로벌 설정
  - @BatchSize: 개별 최적화
  - 이 옵션을 사용하면 커렉션이나 프록시 객체를 한꺼번에 설정한 size만큼 in 쿼리로 조회한다.


- 장점
  - 쿼리 호출 수가 1 + N -> 1 + 1로 최적화 한다.
  - 조인보다 DB 데이터 전송량이 최적화 된다.
  - 페치조인 방식과 비교해서 쿼리 호출 수가 증가하지만, DB 데이터 전송량이 감소한다.
  - 컬렉션 페치조인은 페이징이 불가능하지만 이 방법은 페이징이 가능하다.
- 결론
  - ToOne 관계는 페치 조인해도 페이징에 영향을 주지 않는다. 따라서 ToOne 관계 페지조인으로 쿼리수를
  - 줄이고 해결하고 나머지는 hibernate.default_batch_fetch_size로 최적화 하자

default_batch_fetch_size는 100 ~ 1000 가 적당하다. out of Memory가 날 확률은 100인든 1000이든 같다









## OSIV와 성능최적화